//! Builder script for the crate `unicode_font`.
//! It handles turning Unicode data and extensions into rust code.
//!
//! To update the code, update `Ã™NIDATA` and `EXTENSION` as needed.

use builder::prelude::*;

use anyhow::Context;
use std::collections::HashMap;
use std::io::Read;
use std::io::Write;

const UNIDATA: &str = include_str!("../../unidata/UnicodeData.txt");

const VARIANTS_PATH: &str = "../unidata/Variants.txt";
const EXTENSION_PATH: &str = "../unidata/Extension.txt";
const MAPS_BASE_PATH: &str = "../src/";

fn main() -> anyhow::Result<()> {
    update_standard()?;
    extract_from_standard().context("failed extracting data from standard")?;
    clean_extension().context("failed cleaing extension file")?;
    standard::write_phf_maps_standard().context("failed writing standard maps")?;
    extension::write_phf_maps_extension().context("failed writing extension maps")?;
    Ok(())
}


fn update_standard() -> anyhow::Result<()> {
    let url = "https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt";
    let standard = reqwest::blocking::get(url)?.text()?;
    let mut file = std::fs::OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open(UNIDATA)
        .context(format!("failed writing updated UNICODE standard"))?;
    file.write_all(standard.as_bytes())?;
    Ok(())
}

/// Writes the data as a map in the location `path`.
///
/// # Errors 
/// 
/// If we could not wirte to `path`.
pub fn write_map(data: &[(String, String)], path: &std::path::Path) -> anyhow::Result<()> {
    let mut out = String::new();
    out += "// Do not edit this file! It is generated by a script.\n";
    out += "phf::phf_map! {\n";
    // if data.is_empty() {
    // 	anyhow::bail!("data for the map is empty. The path was {}", path.display());
    // }
    for (input, output) in data {
        out += &format!("    '\\u{{{input}}}' => '\\u{{{output}}}',\n");
    }
    out += "}";

    let mut file = std::fs::OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .context(format!("failed writing map on path {}", path.display()))?;
    file.write_all(out.as_bytes())?;

    Ok(())
}

pub mod standard {
	use super::{write_map, MAPS_BASE_PATH, VARIANTS_PATH};

    use std::str::FromStr;
    use anyhow::Context;
    use builder::prelude::*;
    use std::path::PathBuf;
    use strum::IntoEnumIterator;
    use heck::ToSnakeCase;

    /// Write phf maps based on the UNICODE standard only.
    pub fn write_phf_maps_standard() -> anyhow::Result<()> {
        for variant in Variant::iter() {
            let rdr = csv::ReaderBuilder::new()
                .has_headers(false)
                .comment(Some(b'#'))
                .delimiter(b';')
                .from_path(VARIANTS_PATH)
                .context("failed reading variants file")?;
            write_map_standard(rdr, variant)?;
        }
        Ok(())
    }

    /// Write a standard map. 
    fn write_map_standard(rdr: csv::Reader<std::fs::File>, variant: Variant) -> anyhow::Result<()> {
        let data = get_data(rdr, variant)?;
        let path: PathBuf = [MAPS_BASE_PATH, &format!("{}", variant).to_snake_case()].iter().collect();
        write_map(&data, &path)?;
        Ok(())
    }

    pub fn get_data(
        mut rdr: csv::Reader<std::fs::File>,
        variant: Variant,
    ) -> anyhow::Result<Vec<(String, String)>> {
        let mut data = Vec::new();
        let record_to_plain_data = |record: csv::StringRecord| {
            let code = record
                .get(0)
                .expect("variant record has no code!\n{:record?}")
                .to_string();
            let plain_code = record
                .get(4)
                .expect("variant record has no plain code!\n{:record?}")
                .to_string();
            (code, plain_code)
        };

        let record_to_variant_data = |record: csv::StringRecord| {
            let code = record
                .get(0)
                .expect("variant record has no code!\n{:record?}")
                .to_string();
            let plain_code = record
                .get(4)
                .expect("variant record has no plain code!\n{:record?}")
                .to_string();
            (plain_code, code)
        };

        macro_rules! get_variant { 
        	($variant: ident) => { 
        		for record in rdr.records() {
                    let record = record?;
                    let v = Variant::from_str(
                        record.get(3).context("record has no variant!\n{:record?}")?
                    ).context(format!("failed to parse standard name as variant from record {:#?}", record))?;
                	match v {
                		Variant::$variant => {
                			let d = record_to_variant_data(record);
                			data.push(d);
                		}
                		_ => (),
                	}
                }
            } 
        }

        match variant {
            Variant::Plain => {
                for record in rdr.records() {
                    let record = record?;
        			let d = record_to_plain_data(record);
        			data.push(d);
                }
            }
            Variant::ArabicMathematical => {
            	get_variant!(ArabicMathematical)
            }
            Variant::ArabicMathematicalInitial => {
                get_variant!(ArabicMathematicalInitial)
            }
            Variant::Bold => {
            	get_variant!(Bold)
            }
            Variant::BoldItalic => {
            	get_variant!(BoldItalic)
            }
            Variant::BoldFraktur => {
            	get_variant!(BoldFraktur)
            }
            Variant::BoldScript => {
            	get_variant!(BoldScript)
            }
            Variant::Circled => {
            	get_variant!(Circled)
            }
            Variant::Comma => {
            	get_variant!(Comma)
            }
            Variant::DoubleStruckItalic => {
                get_variant!(DoubleStruckItalic)
            }
            Variant::DoubleStruck => {
            	get_variant!(DoubleStruck)
            }
            Variant::Fraktur => {
            	get_variant!(Fraktur)
            }
            Variant::FullStop => {
            	get_variant!(FullStop)
            }
            Variant::Fullwidth => {
            	get_variant!(Fullwidth)
            }
            Variant::Italic => {
            	get_variant!(Italic)
            }
            Variant::Looped => {
            	get_variant!(Looped)
            }
            Variant::Monospace => {
            	get_variant!(Monospace)
            }
            Variant::NegativeCircled => {
            	get_variant!(NegativeCircled)
            }
            Variant::NegativeSquared => {
            	get_variant!(NegativeSquared)
            }
            Variant::Regional => {
            	get_variant!(Regional)
            }
            Variant::Segmented => {
            	get_variant!(Segmented)
            }
            Variant::Other => {
            	get_variant!(Other)
            }
            Variant::Parenthesized => {
            	get_variant!(Parenthesized)
            }
            Variant::SansSerifBoldItalic => {
            	get_variant!(SansSerifBoldItalic)
            }
            Variant::SansSerifBold => {
            	get_variant!(SansSerifBold)
            }
            Variant::SansSerifItalic => {
            	get_variant!(SansSerifItalic)
            }
            Variant::SansSerif => {
            	get_variant!(SansSerif)
            }
            Variant::MathematicalScript => {
                get_variant!(MathematicalScript)
            }
            Variant::Script => {
            	get_variant!(Script)
            }
            Variant::SmallCapital => {
            	get_variant!(SmallCapital)
            }
            Variant::Superscript => {
            	get_variant!(Superscript)
            }
            Variant::Subscript => {
            	get_variant!(Subscript)
            }
            Variant::Stretched => {
            	get_variant!(Stretched)
            }
            Variant::Squared => {
            	get_variant!(Squared)
            }
            Variant::Tailed => {
            	get_variant!(Tailed)
            }
            Variant::Wide => {
            	get_variant!(Wide)
            }
        }
        Ok(data)
    }
}

pub mod extension {
    use super::{write_map, EXTENSION_PATH, MAPS_BASE_PATH, VARIANTS_PATH};

    use anyhow::Context;
    use builder::prelude::*;
    use std::path::PathBuf;
    use strum::IntoEnumIterator;
    use heck::ToSnakeCase;

    /// Write phf maps based on both the UNICODE standard and our extension.
    pub fn write_phf_maps_extension() -> anyhow::Result<()> {
        for variant in Variant::iter() {
            let rdr_standard = csv::ReaderBuilder::new()
                .has_headers(false)
                .comment(Some(b'#'))
                .delimiter(b';')
                .from_path(VARIANTS_PATH)
                .context("failed reading variants file")?;
            let rdr_extension = csv::ReaderBuilder::new()
                .has_headers(false)
                .comment(Some(b'#'))
                .delimiter(b';')
                .from_path(EXTENSION_PATH)
                .context("failed reading extension file")?;
            write_map_extension(rdr_standard, rdr_extension, variant)?;
        }
        Ok(())
    }

    fn write_map_extension(
        rdr_standard: csv::Reader<std::fs::File>,
        rdr_extension: csv::Reader<std::fs::File>,
        variant: Variant,
    ) -> anyhow::Result<()> {
        let data = get_data_extension(rdr_standard, rdr_extension, variant)?;
        let path: PathBuf = [MAPS_BASE_PATH, &format!("{}.extension", variant.to_string().to_snake_case())].iter().collect();
        write_map(&data, &path)?;
        Ok(())
    }

    pub fn get_data_extension(
        rdr_standard: csv::Reader<std::fs::File>,
        rdr: csv::Reader<std::fs::File>,
        variant: Variant,
    ) -> anyhow::Result<Vec<(String, String)>> {
        let mut data = super::standard::get_data(rdr_standard, variant)?;
        data.extend(super::standard::get_data(rdr, variant)?);
        Ok(data)
    }
}

/// Cleans the extension of variants from those already included in the unicode standard.
fn clean_extension() -> anyhow::Result<()> {
    let mut rdr = csv::ReaderBuilder::new()
        .has_headers(false)
        .comment(Some(b'#'))
        .delimiter(b';')
        .from_path(VARIANTS_PATH)
        .context("failed reading variants file")?;
    let included_codes = rdr
        .records()
        .map(|record| record.expect("failed to read record"))
        .map(|record| record.get(0).expect("failed to get code").to_string())
        .collect::<Vec<String>>();
    let mut rdr = csv::ReaderBuilder::new()
        .has_headers(false)
        .comment(Some(b'#'))
        .delimiter(b';')
        .from_path(EXTENSION_PATH)
        .context("failed reading extension file")?;

    let mut new_extension = csv::WriterBuilder::new()
        .has_headers(false)
        .comment(Some(b'#'))
        .delimiter(b';')
        .from_writer(Vec::new());
    for record in rdr.records() {
        let record = record?;
        if let Some(code) = record.get(0) {
            if included_codes.contains(&code.to_string()) {
                println!("{code} is filtered isnce it is in the standard");
                continue;
            }
        }
        new_extension
            .write_record(&record)
            .context("failed writing record in extension")?
    }
    let new_extension = String::from("\
    	#You can edit this file.\n\
    	#It contains variants not included in the Unicode standard.\n\
		#code;character;name;variant;plain_code;plain_character\n\
    	") + &String::from_utf8(new_extension.into_inner()?)?;
    let mut file = std::fs::OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open(EXTENSION_PATH)
        .context("failed opening extension file")?;
    file.write_all(new_extension.as_bytes())
        .context("failed writing to extension file")?;
    Ok(())
}

/// Extract information from the UNICODE standard.
fn extract_from_standard() -> anyhow::Result<()> {
    let mut out = String::new();
    out += "#Do not edit! This file is automatically extracted from Unicode Data.\n";
    out += "#code;character;name;variant;plain_code;plain_character\n";

    let mut name_map = HashMap::new();

    for line in UNIDATA.lines() {
        let fields: Vec<_> = line.split(";").collect();
        debug_assert_eq!(fields.len(), 15);
        let (code, name, description) = (fields[0], fields[1], fields[5]);
        name_map.insert(code, name);
        // Collect codes with font variants
        if line.contains("<font> ") {
            let plain_code = description.strip_prefix("<font> ").unwrap();
            let character = code_to_character(code);
            let plain_character = code_to_character(plain_code);
            let variant = Variant::parse_standard_name(name)?;
            let line = format!(
                "{};{};{};{};{};{}\n",
                code, character, name, variant, plain_code, plain_character
            );
            out += &line;
        }
    }

    let mut file = std::fs::OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open(VARIANTS_PATH)?;
    file.write_all(out.as_bytes())?;

    // Append plain variants
    let mut file = std::fs::OpenOptions::new()
        .read(true)
        .append(true)
        .open(VARIANTS_PATH)?;
    let mut buf = String::new();
    file.read_to_string(&mut buf)?;

    // Collect plain variants
    let mut v = Vec::new();
    for line in buf.lines().filter(|line| !line.starts_with("#")) {
        let fields: Vec<_> = line.split(";").collect();
        let (plain_code, plain_character) = (fields[4], fields[5]);
        v.push((plain_code, plain_character));
    }
    v.sort();
    v.dedup();

    // Write information
    let mut plain_codes = String::new();
    for (code, character) in v {
        let name = name_map.get(code).unwrap();
        let variant = Variant::Plain;
        let plain_code = code;
        let plain_character = character;
        let line = format!(
            "{};{};{};{};{};{}\n",
            code, character, name, variant, plain_code, plain_character
        );
        plain_codes += &line;
    }
    file.write_all(plain_codes.as_bytes())?;

    Ok(())
}
